# [level 2] 요격 시스템

* [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12926)


### 실행문
```java
import java.util.Arrays;

class Solution {
    public int solution(int[][] targets) {
        int answer = 0;
        
        Arrays.sort(targets, (a, b) -> (Integer.compare(a[1], b[1])));
        
        double lastShot = -1e6;
        
        for(int[] t : targets) {
            
            int s = t[0];
            int e = t[1];
            
            if( !( s < lastShot && lastShot < e )) {
                lastShot = e - 0.5;
                answer++;
            }
            
        }
        
        return answer;
    }
}
```

### ChatGPT
```java
import java.util.*;

class Solution {
    public int solution(int[][] targets) {
        int answer = 0;

        // 1. 끝나는 지점 기준으로 정렬
        Arrays.sort(targets, (a, b) -> 
                    Integer.compare(a[1], b[1]));

        // 2. 마지막으로 요격한 위치 기록
        double lastShot = -1e9;  // 아주 작은 값으로 초기화

        // 3. 구간 순회하면서 요격 미사일 발사
        for (int[] t : targets) {
            int s = t[0];
            int e = t[1];

            // lastShot이 현재 구간 (s, e)에 포함되지 않으면 새로 요격
            // (개구간이라 s < lastShot < e 여야 커버됨)
            if (
                !(s < lastShot && lastShot < e)
                ) {
                // 새 미사일 발사: 끝나는 지점 바로 직전에 쏨
                lastShot = e - 0.5;
                answer++;
            }
        }

        return answer;
    }
}
```

##### 참고사이트

### 느낀점
```
드디어!! 코딩테스트를 회사를 다니지만 시작해야겠다고 다짐을하고 목표로 하던 Lv2 에 진입하였습니다.
처음 열자마자 무슨 이상한 그림있고, 문제 자체의 내용도 엄청나고 문제를 이해했지만.....
어떻게든 풀고 싶어서 1시간정도 고민했는데, 근래 사이드프로젝트나 여러 개인적인 이슈로 인해서 더 이상 시간끌면 아예 코딩테스트 진행도나 흥미가 떨어질것같아서
구글링과 챗형님을 모시고 공부방법을 좀 바꿔야겠다고 생각했습니다.

바로 나오는게 그리드 프로토콜이였고, 대학교때 분명 배웠던것인데, 전혀 기억이 나질 않더군요 ㅋㅋㅋ
덕분에 그리드 프로토콜에 대해서 다시 공부할 수 있었어요.
그리드 프로토콜은 근시안적 방법론에 대표적인 포로토콜이고, 말그대로 근시안적 알고리즘이라서 당장 눈앞에서 최적인 선택만 반복, 부분 최적 == 전체 최적이 가능할때 적립 가능한 프로토콜 이네요.
당연히 시간이 빠르지만, 전체 탐색은 안되기 때문에 전체적으로 최적은 아닌걸로!
반대 프로토콜은 뭐지?? 뭐 근시어쩌고니까, 원시안적인가?? 했는데, 챗형님한테 맞을뻔 ^^;;; 
전역적/전체 탐색 프로토콜이 있고, 당연하게 반대로 전체 구조를 파악하고 중복을 피하기 위해 메모이제이션을 이용하여, 결과를 저장해놔서 같은 계산이 오면 뻥뻥 발로 찬다네요. 그래도 전체 탐색이기 때문에 시간이
굉장히 오래 걸리지만, 전체를 탐색해서 하기 때문에 전체에 맞는 최적을 찾을 수 있다고 하네요.

소스는 Arrays.sort() 를 람다형식으로 Integer.compare(a[1], b[1]); 형식으로 미사일에 끝지점으로 정렬을 하고,
double lastShot = -1e9; 로 초기화 하는데, 처음에는 -1e9로 왜 초기화하지? 0으로 하면 안되나? 했는데, 미사일이 {-300, -200}; 처럼 들어올 수도 있으니까... 와...
이후 for문으로 이미 정렬된 미사일 경로를 하나씩 빼서 (9 < 9.5 && 9.5 < 10); 이런식으로 포함이 되는지 확인을하고 
새로 쏴야한다! 하면 lastShot에 e를 넣는건 이해되는데, -0.5를 왜하지? 했는데 조건을 생각해보니 0.5, 0.1 어느수로 해놔도 상관없고 10, 10 이 연속으로 들어오면 포함시켜야하는데 글로는 설명이 영... ㅋㅋㅋ
하고 이제 answer++;  굳굳굳굳 

처음 경험해보는 레벨2 였지만, 저한테는 의미가 있는 또하나의 시작점인것 같아요.
남들이 볼때는 하찮거나 그거밖에 못하누 ㅋㅋ 라고 할 수 있어도, 회사를 다니면서나 주말이나 퇴사를 해서나 저의 자유시간을 이용해서 꾸준하게 개발이라는 능력을 키우고 싶다 라는 마음을 지켜주는 소재이고,
앞으로도 어떤 회사를 가든 어떤 환경이든 핑계되지 않고 더 열심히 해서 레벨 5까지 풀어보고 싶어요 ㅋㅋㅋ 궁금 
미리 보면 재미없으니까, 그정도 실력되면 그때 열어보기로 ㅋㅋㅋㅋ

잡담과 설명이 길었네요. 너무 재미있었습니다!!! 굳굳굳굳
근데 너무 시간 오래씀 ㅠㅠ;;
``` 