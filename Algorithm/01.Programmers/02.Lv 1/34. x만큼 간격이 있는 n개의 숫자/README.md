# [level 1] x만큼 간격이 있는 n개의 숫자

* [문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12954#)


### 실행문
```java
class Solution {
    public long[] solution(int x, int n) {
        long[] answer = new long[n];
        int ncnt = 0;
        
        for(int i = 0; i < n; i++) {
            ncnt++;
            answer[i] = Long.valueOf(x) * Long.valueOf(ncnt);    
        }
        
        return answer;
    }
}   
```

### ChatGPT
```java
class Solution {
    public long[] solution(int x, int n) {
        long[] answer = new long[n];
        
        for (int i = 0; i < n; i++) {
            answer[i] = (long) x * (i + 1);
        }
        
        return answer;
    }
}
```

##### 참고사이트

### 느낀점
```
이번 문제도 엄청 간단한 문제였던거 같아요.
딱 보자마자 바로 전 문제 프로토콜이 생각나서 의도치 않게 이중for문이 없나 찾고 있는 저를 보고 문제를 맞이할때는 객관적이게 생각도 정리해야된다는 생각을 했네요.
결국 문제는 곱한 수 만큼 배열로 반환하면 되는거였고, 제가 작성한 소스중에 ncnt 를 따로 만들어서 ncnt++; 해주는 부분이 있는데,
다 작성하고 제 소스 리뷰를 해보니 +1 로 하면 될걸 구지 ncnt라는 변수를 생성해서 일일히 카운트를 해주고 있더라구요.
당장 문제되는 부분 해결도 중요하지만, 문제 도중에도 조금 시야를 넓게보고 수시로 전체적은 프로토콜 흐름을 파악해야 겠다는걸 배웠네요.
문제를 다 풀고 테스트는 전체 통과해서 제출 눌렀는데, 마지막 항복 2항목이 계속 실패라고 나와서 삽질좀 했습니다... ㅋㅋㅋㅋ
long 배열이라서 정수나 음수나 문제 조건에도 조건으로 long 크기 이상으로 된 수가 안넘어오는걸 알고 있음에도
테스트 케이스에 정수, 음수, 많은 수 다 해보니 안되섴ㅋㅋㅋ 
결국에는 타입으로 보니 int형으로 x와 y가 들어오는데, 계산을 int형으로 바로 하다보니 int형의 크기를 벗어나는 오버플로우 현상이였네요.
계산하기전에 long 타입으로 타입을 바꿔서 하니까 정상적으로 마무리 할 수 있었습니다.
신기.. ㅋㅋㅋ 이제 그래도 어느정도 문제를 풀어봤다고 주석으로 하나하나씩 체크해가면서 풀어가는 재미가 많은것 같아요 ㅋㅋㅋㅋㅋㅋㅋㅋㅋ
챗형님은 제가 위에서 얘기한 ncnt 를 없애고 +1으로 처리, x만 long변환하여 가독성 처리를 한것 같네요.
역시 쉬운문제인것처럼 보이지만, 개발자 역량에 따라서 천차만별이라는 것을 느끼는 문제였고, 이번 문제도 개꿀잼 이였습니다.
``` 
<img src="스크린샷 2025-05-17 오후 1.44.48.png" width="600"/>
